#НИХРЕНАНЕРАБОТАЕТ
## Небольшой пример работы с NUMA памятью
Для запуска потребуется поставить библиотеку для работы с нумой. На ubuntu это делается так: `apt-get install libnuma-dev`. Когда библиотека есть, можно спокойно запускать cmake с целью `example`.

### Про пример
В примере можно посмотреть основные функции для работы с numa.


Пример можно запустить и посмотреть на вывод, иногда интересно увидеть разные результаты на (казалось бы) очень похожих функциях.

Замеряется время заполнения и вычисления суммы на массиве.



### Аллокация памяти на ноде
* `numa_alloc_onnode(size, node)` -- самое важное, что надо знать. Аллоцирует память. _(может зафейлиться, если не хватает памяти или если аллокация на данной ноде невозможна. или еще если такой ноды в принципе нет)_
* `numa_free(*start, size)` -- второе по важности. Чистит память.


* Можно проверить сколько памяти доступно на ноде: `numa_node_size()`
* Можно проверять какие ноды доступны для аллокации: `numa_get_mems_allowed()`, `numa_get_membind()`


* Еще можно переносить данные на нужную ноду. На текущую: `numa_setlocal_memory(*start, size)`. На конкретную: `numa_tonode_memory(*start, size)`

### Запуск на ноде
* cpu распределены по нодам, так что можно как-то внешне запускаться на конкретном cpu
* есть запуск на конкретной ноде или на наборе нод: `numa_run_on_node(node)` или `numa_run_on_node_mask(mask)`
* `numa_bind(mask)` -- прикрепляет выполнение к конкретным нодам и запрещает аллоцировать память на других нодах 

### Определение текущей ноды
* `numa_get_run_node_mask()` _returns a mask of CPUs on which the current task is allowed to run_. Проверяет есть ли какие-то ограничения по нодам. Наример, такие ограничения накладвает `numa_run_on_node()` 
* `numa_node_of_cpu(cpu)` -- определяет ноду по cpu. Узнать cpu библиотека не позволяет :(
* определить текущий cpu можно, например, с помощью `sched_getcpu()` из `sched.h` _(я не знаю другой способ, но знаю, что этот работает долго)_